# -*- mode: Org; -*-
# If you are not using emacs you are a dick ;^).

* General concept
  Simple text-based(or no?) multiplayer shooter.
  Client-server mechanism based on a binary protocol.

** todo for all
*** TODO Try to figure out what should be a battle mechanism.
*** TODO Makefile: passing parameters for each part(server, client)
    For a while should be used "make CFLAGS=-D[_SERVER_|_CLIENT_] [server|client]".

    MR 20110415T06:14:34Z 003 <[AvataR]> 
    build/server/%.o : src/%.c
        $(CXX) $(CFLAGS) -DSERVER $@ $<
    build/client/%.o : src/%.c
        $(CXX) $(CFLAGS) -DCLIENT $@ $<                 
    
    MR 20110415T06:14:55Z 000 <пкщгяут[slacktop]> [AvataR] не подходит
    MR 20110415T06:14:59Z 000 <[AvataR]> схуяле?
    MR 20110415T06:15:01Z 000 <пкщгяут[slacktop]> у меня файл cdata.c общий
    MR 20110415T06:15:10Z 000 <[AvataR]> ну и что?
    MR 20110415T06:15:12Z 000 <пкщгяут[slacktop]> гм
    MR 20110415T06:15:22Z 000 <пкщгяут[slacktop]> т.е ты предлагаешь создавать два разных обьектника?
    MR 20110415T06:15:37Z 000 <[AvataR]> ну ты же создаешь два разных объектника? ))
    MR 20110415T06:15:39Z 000 <пкщгяут[slacktop]> алсо, что значят $@ $< ?
    MR 20110415T06:15:45Z 000 <пкщгяут[slacktop]> нет
    MR 20110415T06:15:47Z 000 <[AvataR]> $@ -- цель
    MR 20110415T06:15:53Z 000 <[AvataR]> $< - первый деп
  
* Closer details
** Server

   How it works:
   Server side has a three threads: 
   1. receives messages from the clients and puts it into messages queue;
   2. handles each message from the messages queue, updates the world's state
      and sends difference to each client. Also, for each client it checks `seq` 
      number from the `struct msg` and if `seq` differs very hard with the
      server's `seq`, thread sends whole world's state to that client.
   3. this thread sends query to each client for getting its `seq` number
      and checking connection state(keep alive) and if `seq` of the client
      is much different, thread sends whole world's state to that client.
   

   players list -+-> player 1 -> recieves data and inserts it into messages queue
   (slots)       +-> player 2 <-.                    |
                 +-> ...        |                    |
                 '-> player n   |                    |
                                |            ________V_______
   world -> queue manager <---------------- ( messages queue )
            Fetchs messages then updates     ----------------
            the world and sends them to the players.


   queue_mngr_func() not always sends diffs to all players.
   Player see only its viewport's zone around it, so it should not know about
   events which happen outside of its visibility range, or for example
   connection event which concerns only one player who sends it.

*** todo for the server side.
**** TODO Write function sync_mngr_func()
**** Write a handling of the events within queue_mngr_func()
***** DONE For begin let's handle connection event.
****** DONE Make handshaking with client.
***** Disconnect event from client and server
****** DONE Client
****** DONE Server
**** TODO add uint8_t key[KEY_LEN] to `struct player`
     It's necessary for security reason.
     For example a client wants to disconnect from the server, it sends
     message with its id and server like the fucking stupid moron disconnects
     other client, because the first client just changed value of id field
     in the message's header. Oops!
**** TODO Think about synchronization between the server and a clients more detail.
     see item about sync_mngr_func() too.

** Client

   First thread draws the user interface and sends a data to the server.
   Second recieves a data and sends the signal to the first.

   How it works:
   Let's suggest that FPS = 5, UI reads user's input 5 times
   per second and each time it sends the data with events to the
   server. When another thread recieves the data it blocks the 
   world's state, updates them, and then UI can be updated.
   That's all ;^).


       client in mostly works like a server.
     ,--------
     |
     +- msgqueue_mngr_thread: works like in a server part.
     |
     +- ui_mngr_thread: just init ui.
     |
     +- recv_mngr_thread: receives messages from server and adds them to msgqueue.
     |                    Also it must watch on each message type from batch and if
     |                    necessary handles some of them and than sends result to the server.
     |
     +- send_mngr_thread: reads last event and sends message to server. TODO: cancel.
     |
     +- ui_read_thread: reads user's actions and updates last event variable. TODO: cancel.
     |                  Must be implemented for each ui backend.
     |
     `- ui_update_thread: reads msgqueue and updates UI accordingly.
                          Must be implemented for each ui backend. TODO: cancel.
            

*** UI
    
    It must be like:
    
    +-------------------------------------+
    | Status line                         |
    |-------------------------------------|
    | ................................... |
    | ................................... |
    | ................................... |
    | ................................... |
    | ...........Scrolled Map............ |
    | ................................... |
    | ...........Here must be............ |
    | ........a various objects.......... |
    | ................................... |
    | ................................... |
    | ................................... |
    | ................................... |
    |-------------------------------------|
    | Notify line                         |
    +-------------------------------------+

    Status line should look like that:

    Nick   W: Rocket(90/40)   HP: 100/100


    When Tab is pressed, statistics about players should be requested from the
    server and displayed in a way like that:

     Nick                    | Kill | Death
    -------------------------+------+-------
     Player                     1       3
     Gamer                      8       2
     Loser                      0      11
    ----------------------------------------

*** Just a fucking todo for the client part
**** TODO Write basic UI in ncurses
     Must be an opportunity to write UI in various toolkits(SDL, OGL, and etc).
**** TODO Think about events(actions) that client can makes
     For example: to shoot, to run, to die, to take up an objects and so on.
     Write general functions and data structures for 
     the binary protocol(cdata.c, cdata.h).

