#include <math.h>
#include <ncurses.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define BACKGROUND_CHAR ' '
#define WORLD_ITEM_CHAR ('-' | A_DIM)
#define CLOCKID CLOCK_REALTIME
#define SIG SIGRTMIN

enum direction {
    LEFT,
    RIGHT,
    UP,
    DOWN
};

enum player_type {
    ME,
    TEAMMATE,
    ENEMY
};

/* In order of keys in enum player_type */
int players_chars[] = {
    'X' | A_BOLD,
    'X' | A_BOLD | COLOR_PAIR(1),
    'X' | A_BOLD | COLOR_PAIR(2)
};

struct world_item {
    int x, y;
};

struct player_item {
    int x, y;
    enum player_type type;
};



WINDOW *window = NULL;
int ch = '\0', /* last character user typed */
    /* player's location at map */
    x, y,
    /* Viewport is an area that is displayed on the screen */
    viewport_width, viewport_height,
    /* Map may be bigger than viewport (that is always 80x25), so we need some
     * offsets of viewport relative to left upper corner (0,0) of map */
    offset_x, offset_y;
int world_items_n;
struct world_item *world_items = NULL;
int player_items_n;
struct player_item *player_items = NULL;
int map_height, map_width;


void clear_screen(void);
void show_world_items(void);
void move_player(enum player_type, int, int, enum direction);
void update_players(void);
void update_status(const char*, int, const char*, int, int);
void update_ui(void);
static void handler(int, siginfo_t*, void*);

int main() {
    int i;

    timer_t timerid;
    struct sigevent sev;
    struct itimerspec its;
    sigset_t mask;
    struct sigaction sa;

    srand(time(NULL));

    /* establishing signal handler */
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = handler;
    sigemptyset(&sa.sa_mask);
    sigaction(SIG, &sa, NULL);

    /* block signal for a while */
    sigemptyset(&mask);
    sigaddset(&mask, SIG);
    sigprocmask(SIG_SETMASK, &mask, NULL);

    /* create timer */
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIG;
    sev.sigev_value.sival_ptr = &timerid;
    timer_create(CLOCKID, &sev, &timerid);

    /* start timer */
    its.it_value.tv_sec = 0;
    its.it_value.tv_nsec = 100000000;
    its.it_interval.tv_sec = its.it_value.tv_sec;
    its.it_interval.tv_nsec = its.it_value.tv_nsec;
    timer_settime(timerid, 0, &its, NULL);

    /* unblock the signal */
    sigprocmask(SIG_UNBLOCK, &mask, NULL);


    /* generate map's size */
    map_height = 100 + rand() % 500;
    map_width = 100 + rand() % 500;

    /* generate other players
     * Equation is absolutely arbitrary */
    player_items_n = sqrt(map_width * map_height) + rand() % 40;
    player_items = malloc(player_items_n * sizeof(struct player_item));
    for(i=0; i < player_items_n; i++) {
        /* add one to each coordinate so objects wouldn't be placed right at
         * the left corner of map.
         * Substitute one from modulo for the same reason */

        player_items[i].x = 1 + rand() % (map_width - 1);
        /* 1 line is reserved for status line */
        player_items[i].y = 2 + rand() % (map_height - 1);
        player_items[i].type = (rand() % 2) ? TEAMMATE : ENEMY;
    }

    /* generate world items */
    world_items_n = 15 + rand() % 360;
    world_items = malloc(world_items_n * sizeof(struct world_item));
    for(i=0; i < world_items_n; i++) {
        world_items[i].x = 1 + rand() % (map_width - 1);
        world_items[i].y = 2 + rand() % (map_height - 1);
    }


    /* initializing ncurses mode */
    initscr();

    /* by default, we're loking at the center of map */
    offset_x = (map_width - COLS)/2;
    offset_y = (map_height - LINES)/2;

    /* user is right in the center of map */
    x = map_width/2;
    y = map_height/2;
   
    cbreak();
    noecho();
    keypad(stdscr, TRUE);

    if(has_colors() == FALSE) {
        endwin();
        fprintf(stderr, "Colors is not supported by this terminal.\n");
        free(world_items);
        free(player_items);
        exit(1);
    }
    start_color();
    init_pair(1, COLOR_GREEN, COLOR_BLACK);
    init_pair(2, COLOR_RED, COLOR_BLACK);

    curs_set(0); /* Invisible cursor */
    refresh();

    if(LINES < 25 || COLS < 80) {
        endwin();
        fprintf(stderr, "Terminal should be at least 80x25 in size!\n");
        exit(1);
    } else if (LINES >= 27 && COLS >= 82) {
        /* box() would draw *inside* borders, so we need a window that is two
         * rows/cols wider than 80x25 */
        window = newwin(LINES, COLS, 0, 0);
        box(window, 0, 0);
        viewport_width = COLS - 2;
        viewport_height = LINES - 2;
    } else {
        /* terminal is about 80x25 in size, so no borders are needed */
        window = newwin(LINES, COLS, 0, 0);
        viewport_width = COLS;
        viewport_height = LINES;
    }
    mvwaddch(window, map_height/2 - offset_y, map_width/2 - offset_x, players_chars[ME]);
    /* initialize status with some arbitrary data */
    update_status("Minoru", 100, "Gun", 0, 100);
    wrefresh(window);
    refresh();

    while(ch != 'q') {
        ch = getch();
    }

    endwin();

    return 0;
}

/* Removes (by overwriting with a background character) all visible objects
 * from the screen, thus making it clear and ready to be drawn on */
void clear_screen(void) {
    int i,
        player_x, player_y,
        item_x, item_y;

    /* do not try to print anywhere outside of visible part of window
     * The main purpose of that is keeping boundaries created by box()
     * consistent */
    if(    (x > offset_x)     && (x <= offset_x + viewport_width)
        && (y > offset_y + 2) && (y <= offset_y + viewport_height))
    {
        mvwaddch(window, y - offset_y, x - offset_x, BACKGROUND_CHAR);
    }

    for(i = 0; i < player_items_n; i++) {
        player_x = player_items[i].x;
        player_y = player_items[i].y;

        if(    (player_x > offset_x)     && (player_x <= offset_x + viewport_width)
            && (player_y > offset_y + 2) && (player_y <= offset_y + viewport_height))
        {
            mvwaddch(window, player_y - offset_y, player_x - offset_x, BACKGROUND_CHAR);
        }
    }

    for(i = 0; i < world_items_n; i++) {
        item_x = world_items[i].x;
        item_y = world_items[i].y;
        if(    (item_x > offset_x)     && (item_x <= offset_x + viewport_width)
            && (item_y > offset_y + 2) && (item_y <= offset_y + viewport_height))
        {
            mvwaddch(window, item_y - offset_y, item_x - offset_x, BACKGROUND_CHAR);
        }
    }
}

/* Runs through all the items in the world and shows those that are visible in
 * a viewport */
void show_world_items(void) {
    int i, item_x, item_y;

    for(i=0; i < world_items_n; i++) {
        item_x = world_items[i].x;
        item_y = world_items[i].y;

        if(    (item_x > offset_x)     && (item_x <= offset_x + viewport_width)
            && (item_y > offset_y + 2) && (item_y <= offset_y + viewport_height))
        {
            mvwaddch(window, item_y - offset_y, item_x - offset_x, WORLD_ITEM_CHAR);
        }
    }
}

/* Adds player at the position specified with point at the map and direction */
void move_player(enum player_type type, int x, int y, enum direction dir) {
    switch(dir) {
        case LEFT:
            x--;
            break;

        case RIGHT:
            x++;
            break;

        case UP:
            y--;
            break;

        case DOWN:
            y++;
            break;
    }
    if(    (x > offset_x)     && (x <= offset_x + viewport_width)
        && (y > offset_y + 2) && (y <= offset_y + viewport_height))
    {
        mvwaddch(window, y - offset_y, x - offset_x, players_chars[type]);
    }
}

/* Updates state of teammates and enemies and displays them
 *
 * This function is specific to proof-of-concept client and we don't need to
 * port it to backend */
void update_players(void) {
    int i, player_x, player_y;

    for(i=0; i < player_items_n; i++) {
        if(rand() % 2) {
            player_items[i].x += rand() % 3 - 1;
        } else {
            player_items[i].y += rand() % 3 - 1;
        }

        player_x = player_items[i].x;
        player_y = player_items[i].y;
        if(    (player_x > offset_x)     && (player_x <= offset_x + viewport_width)
            && (player_y > offset_y + 2) && (player_y <= offset_y + viewport_height))
        {
            mvwaddch(window, player_y - offset_y, player_x - offset_x, players_chars[player_items[i].type]);
        }
    }
}

/* Updates statusline shown at the top line of viewport */
void update_status(const char* nick, int hp, const char* weapon,
                   int min_damage, int max_damage)
{
    int i, space_width;
    char *status_line, *hp_str, *weapon_str, *tmp;

    /* This is the line that would be shown
     * Space at the beginning delimits it from the border of viewport */
    status_line = malloc(viewport_width * sizeof(char));
    status_line[0] = '\0';

    tmp = malloc(viewport_width * sizeof(char));
    tmp[0] = '\0';

    /* part of string that stores health points stats */
    hp_str = malloc(12 * sizeof(char));
    hp_str[0] = '\0';

    /* part of string that stores current weapon name and it min/max damage */
    weapon_str = malloc(22 * sizeof(char));
    weapon_str[0] = '\0';

    
    /* Health points block
     * Would look like this: HP: 100/100 */
    strcpy(hp_str, "HP: ");
    sprintf(tmp,"%d",hp);
    strcat(hp_str, tmp);
    strcat(hp_str, "/100");


    /* Weapon block
     * Would look like this: W: Gun (0-100) */
    strcpy(weapon_str, "W: ");
    strcat(weapon_str, weapon);
    strcat(weapon_str, " (");
    sprintf(tmp, "%d", min_damage);
    strcat(weapon_str, tmp);
    strcat(weapon_str, "-");
    sprintf(tmp, "%d", max_damage);
    strcat(weapon_str, tmp);
    strcat(weapon_str, ")");

    /* Concateneting strings together to get resulting status line */
    strcat(status_line, nick);
    /* add spaces to center weapon_str */
    space_width = viewport_width - 2 - strlen(nick) - strlen(hp_str) - strlen(weapon_str);
    space_width = floor(space_width / 2);
    for(i = 0; i < space_width; i++)
        tmp[i] = ' ';
    tmp[space_width] = '\0';
    strcat(status_line, tmp);
    strcat(status_line, weapon_str);
    /* add more space to make hp_str right-aligned */
    space_width = viewport_width - 2 - strlen(nick) - strlen(hp_str) - strlen(weapon_str);
    space_width = ceil(space_width / 2);
    for(i = 0; i < space_width; i++)
        tmp[i] = ' ';
    tmp[space_width] = '\0';
    strcat(status_line, tmp);
    strcat(status_line, hp_str);

    /* remove previous status line from the screen */
    for(i=1; i<viewport_width; i++)
        mvwaddch(window, 1, i, ' ');
    /* put new one onto the same place */
    if(viewport_width > 82 && viewport_height > 27) {
        mvwaddstr(window, 1, 2, status_line);
    } else {
        mvwaddstr(window, 1, 1, status_line);
    }
    
    free(tmp);
    free(hp_str);
    free(weapon_str);
    free(status_line);
}

/* Applies all the changes made to screen by other functions */
void update_ui() {
    wrefresh(window);
}

/* Signal handler used to do all the functions calls to update the state of
 * world
 *
 * We would need to partially port it to shoooter */
static void handler(int sig, siginfo_t* si, void* uc) {
    /* remove all visible objects from the screen */
    clear_screen();
    /* take user's input and decide where to move player's character */
    if(ch != '\0') {
        switch(ch) {
            case KEY_LEFT:
                /* map scrolling
                 * moves viewport when apropriate, moves player's character
                 * otherwise */
                if((x <= offset_x + ceil(viewport_width/2) + 1) && (offset_x != 0)) {
                    offset_x--;
                }
                move_player(ME, x, y, LEFT);
                x--;
                break;

            case KEY_RIGHT:
                if((x > viewport_width/2) && (offset_x < map_width - viewport_width)) {
                   offset_x++;
                }
                move_player(ME, x, y, RIGHT);
                x++;
                break;

            case KEY_UP:
                if((y <= offset_y + ceil(viewport_height/2) + 1) && (offset_y != 0)) {
                    offset_y--;
                }
                move_player(ME, x, y, UP);
                y--;
                break;

            case KEY_DOWN:
                if((y > viewport_height/2) && (offset_y < map_height - viewport_height)) {
                   offset_y++;
                }
                move_player(ME, x, y, DOWN);
                y++;
                break;
        }
        ch='\0';
    }
    /* update the state of teammates and enemies, then show them */
    update_players();
    /* show other items avaliable at this map */
    show_world_items();
    /* make sure player's character is drawn
     *
     * That's a dirty hack to prevent user's character from being overwritten
     * by some other player or item. We won't need it in shooter because server
     * would eliminate collisions */
    mvwaddch(window, y - offset_y, x - offset_x, players_chars[ME]);
    /* Apply changes made by previous functions */
    update_ui();
    /* Next time that signal should be processed with the same handler */
    signal(sig, (__sighandler_t)&handler);
}

